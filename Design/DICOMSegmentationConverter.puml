@startuml

package dcmqi {

    class SegmentAttributes
    class Segmentation
    SegmentInformationReader <|-- SegmentInformationCSVReader
    SegmentInformationReader <|-- SegmentInformationJSONReader

    SegmentInformationWriter <|-- SegmentInformationCSVWriter
    SegmentInformationWriter <|-- SegmentInformationJSONWriter

    SegmentInformationReader --* SegmentAttributes : use
    SegmentInformationWriter --* SegmentAttributes : use

    note as bla
      DICOM Segmentation conversion
      1. itk -> dcm
      2. dcm -> itk
      Label/Segment information
      transmitted using json OR csv
    end note

    note as SegmentationNote
        Here it would make sense to provide
        as many default attributes as possible
    end note

    SegmentationNote <- Segmentation
}

package JSON <<Database>> {
}

package CSV <<Database>> {
}

SegmentInformationCSVReader --> CSV : reads
SegmentInformationCSVWriter --> CSV : writes

SegmentInformationJSONReader --> JSON : reads
SegmentInformationJSONWriter --> JSON : writes



abstract class SegmentInformationReader {
    + attributes : SegmentAttributes[]
    + SegmentInformationReader(string inputFileName)
    + {abstract} read() : bool
}

class Segmentation {
    + seriesNumber: int
    + seriesDescription: string
}

class SegmentInformationCSVReader {
    read() : bool
}

class SegmentInformationJSONReader {
    read() : bool
}

abstract class SegmentInformationWriter {
    + attributes : SegmentAttributes[]
    + SegmentInformationWriter()
    + {abstract} write(string filename) : bool
}

class SegmentInformationCSVWriter {
    write(string filename) : bool
}

class SegmentInformationJSONWriter {
    write(string filename) : bool
}

class SegmentAttributes {
    - labelID : unsigned
    - attributesDictionary : map<string, string>
    + setLabelID(unsigned labelID) : void
    + lookupAttribute(string key) : string
    + populateAttributesFromString(string attributesStr) : int
    + PrintSelf() : void
}

@enduml